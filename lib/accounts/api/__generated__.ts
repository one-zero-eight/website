/**
 * Generated by orval v6.26.0 üç∫
 * Do not edit manually.
 * InNoHassle Accounts API
 * 
### About this project

This is the API for Accounts project in InNoHassle ecosystem developed by one-zero-eight community.

Backend is developed using FastAPI framework on Python.

Note: API is unstable. Endpoints and models may change in the future.

Useful links:
- [Frontend source code](https://github.com/one-zero-eight/InNoHassle-Website)
- [Website](https://innohassle.ru/)

 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";
import { axiosQuery } from "./axios";
import { queryOptionsMutator } from "./query";
export type LogoutParams = {
  redirect_uri: string;
};

export type TokensGenerateSportTokenParams = {
  telegram_id?: number | null;
  innohassle_id?: string | null;
  email?: string | null;
};

export type TokensGenerateServiceTokenParams = {
  /**
   * Some string that will be in `sub` field of JWT token. Actually, it may be anything.
   */
  sub: string;
  /**
   * List of scopes that will be in `scope` field of JWT token. Default is ['users']
   */
  scopes?: AvailableScopes[];
  /**
   * Generate token only for current user - other users will be marked as not existing in the system
   */
  only_for_me?: boolean;
};

export type TokensGenerateTokenParams = {
  sub: string;
  /**
   * Space delimited list of scopes
   */
  scope?: string | null;
};

export type ProvidersInnopolisLoginOrRegisterParams = {
  redirect_uri: string;
  prompt?: "none" | null;
};

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type UserInfoFromSSOName = string | null;

export type UserInfoFromSSOIssuedAt = string | null;

export interface UserInfoFromSSO {
  email: string;
  issued_at?: UserInfoFromSSOIssuedAt;
  name?: UserInfoFromSSOName;
}

export type UserTelegram = TelegramWidgetData | null;

export type UserInnopolisSso = UserInfoFromSSO | null;

export interface User {
  /** MongoDB document ObjectID */
  id: string;
  innohassle_admin: boolean;
  innopolis_sso: UserInnopolisSso;
  telegram: UserTelegram;
}

export interface TokenData {
  access_token: string;
}

export type TelegramWidgetDataUsername = string | null;

export type TelegramWidgetDataPhotoUrl = string | null;

export type TelegramWidgetDataLastName = string | null;

export interface TelegramWidgetData {
  auth_date: number;
  first_name: string;
  hash: string;
  id: number;
  last_name?: TelegramWidgetDataLastName;
  photo_url?: TelegramWidgetDataPhotoUrl;
  username?: TelegramWidgetDataUsername;
}

export interface TelegramLoginResponse {
  need_to_connect: boolean;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export type AvailableScopes =
  (typeof AvailableScopes)[keyof typeof AvailableScopes];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AvailableScopes = {
  users: "users",
  sport: "sport",
} as const;

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];

/**
 * @summary Innopolis Login Or Register
 */
export const providersInnopolisLoginOrRegister = (
  params: ProvidersInnopolisLoginOrRegisterParams,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<unknown>(
    { url: `/providers/innopolis/login`, method: "GET", params, signal },
    options,
  );
};

export const getProvidersInnopolisLoginOrRegisterQueryKey = (
  params: ProvidersInnopolisLoginOrRegisterParams,
) => {
  return [`/providers/innopolis/login`, ...(params ? [params] : [])] as const;
};

export const useProvidersInnopolisLoginOrRegisterQueryOptions = <
  TData = Awaited<ReturnType<typeof providersInnopolisLoginOrRegister>>,
  TError = HTTPValidationError,
>(
  params: ProvidersInnopolisLoginOrRegisterParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof providersInnopolisLoginOrRegister>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getProvidersInnopolisLoginOrRegisterQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof providersInnopolisLoginOrRegister>>
  > = ({ signal }) =>
    providersInnopolisLoginOrRegister(params, requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof providersInnopolisLoginOrRegister>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ProvidersInnopolisLoginOrRegisterQueryResult = NonNullable<
  Awaited<ReturnType<typeof providersInnopolisLoginOrRegister>>
>;
export type ProvidersInnopolisLoginOrRegisterQueryError = HTTPValidationError;

/**
 * @summary Innopolis Login Or Register
 */
export const useProvidersInnopolisLoginOrRegister = <
  TData = Awaited<ReturnType<typeof providersInnopolisLoginOrRegister>>,
  TError = HTTPValidationError,
>(
  params: ProvidersInnopolisLoginOrRegisterParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof providersInnopolisLoginOrRegister>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useProvidersInnopolisLoginOrRegisterQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Innopolis Callback
 */
export const providersInnopolisCallback = (
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<unknown>(
    { url: `/providers/innopolis/callback`, method: "GET", signal },
    options,
  );
};

export const getProvidersInnopolisCallbackQueryKey = () => {
  return [`/providers/innopolis/callback`] as const;
};

export const useProvidersInnopolisCallbackQueryOptions = <
  TData = Awaited<ReturnType<typeof providersInnopolisCallback>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof providersInnopolisCallback>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getProvidersInnopolisCallbackQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof providersInnopolisCallback>>
  > = ({ signal }) => providersInnopolisCallback(requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof providersInnopolisCallback>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ProvidersInnopolisCallbackQueryResult = NonNullable<
  Awaited<ReturnType<typeof providersInnopolisCallback>>
>;
export type ProvidersInnopolisCallbackQueryError = unknown;

/**
 * @summary Innopolis Callback
 */
export const useProvidersInnopolisCallback = <
  TData = Awaited<ReturnType<typeof providersInnopolisCallback>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof providersInnopolisCallback>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useProvidersInnopolisCallbackQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Telegram Connect
 */
export const providersTelegramConnect = (
  telegramWidgetData: TelegramWidgetData,
  options?: SecondParameter<typeof axiosQuery>,
) => {
  return axiosQuery<unknown>(
    {
      url: `/providers/telegram/connect`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: telegramWidgetData,
    },
    options,
  );
};

export const getProvidersTelegramConnectMutationOptions = <
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof providersTelegramConnect>>,
    TError,
    { data: TelegramWidgetData },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof providersTelegramConnect>>,
  TError,
  { data: TelegramWidgetData },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof providersTelegramConnect>>,
    { data: TelegramWidgetData }
  > = (props) => {
    const { data } = props ?? {};

    return providersTelegramConnect(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ProvidersTelegramConnectMutationResult = NonNullable<
  Awaited<ReturnType<typeof providersTelegramConnect>>
>;
export type ProvidersTelegramConnectMutationBody = TelegramWidgetData;
export type ProvidersTelegramConnectMutationError = void | HTTPValidationError;

/**
 * @summary Telegram Connect
 */
export const useProvidersTelegramConnect = <
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof providersTelegramConnect>>,
    TError,
    { data: TelegramWidgetData },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationResult<
  Awaited<ReturnType<typeof providersTelegramConnect>>,
  TError,
  { data: TelegramWidgetData },
  TContext
> => {
  const mutationOptions = getProvidersTelegramConnectMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Telegram Login
 */
export const providersTelegramLogin = (
  telegramWidgetData: TelegramWidgetData,
  options?: SecondParameter<typeof axiosQuery>,
) => {
  return axiosQuery<TelegramLoginResponse>(
    {
      url: `/providers/telegram/login`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: telegramWidgetData,
    },
    options,
  );
};

export const getProvidersTelegramLoginMutationOptions = <
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof providersTelegramLogin>>,
    TError,
    { data: TelegramWidgetData },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof providersTelegramLogin>>,
  TError,
  { data: TelegramWidgetData },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof providersTelegramLogin>>,
    { data: TelegramWidgetData }
  > = (props) => {
    const { data } = props ?? {};

    return providersTelegramLogin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ProvidersTelegramLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof providersTelegramLogin>>
>;
export type ProvidersTelegramLoginMutationBody = TelegramWidgetData;
export type ProvidersTelegramLoginMutationError = void | HTTPValidationError;

/**
 * @summary Telegram Login
 */
export const useProvidersTelegramLogin = <
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof providersTelegramLogin>>,
    TError,
    { data: TelegramWidgetData },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationResult<
  Awaited<ReturnType<typeof providersTelegramLogin>>,
  TError,
  { data: TelegramWidgetData },
  TContext
> => {
  const mutationOptions = getProvidersTelegramLoginMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get current user info if authenticated
 * @summary Get Me
 */
export const usersGetMe = (
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<User>({ url: `/users/me`, method: "GET", signal }, options);
};

export const getUsersGetMeQueryKey = () => {
  return [`/users/me`] as const;
};

export const useUsersGetMeQueryOptions = <
  TData = Awaited<ReturnType<typeof usersGetMe>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof usersGetMe>>, TError, TData>
  >;
  request?: SecondParameter<typeof axiosQuery>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUsersGetMeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersGetMe>>> = ({
    signal,
  }) => usersGetMe(requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetMe>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UsersGetMeQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetMe>>
>;
export type UsersGetMeQueryError = void;

/**
 * @summary Get Me
 */
export const useUsersGetMe = <
  TData = Awaited<ReturnType<typeof usersGetMe>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof usersGetMe>>, TError, TData>
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useUsersGetMeQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get user by telegram id
 * @summary Get User By Telegram Id
 */
export const usersGetUserByTelegramId = (
  telegramId: number,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<User>(
    { url: `/users/by-telegram-id/${telegramId}`, method: "GET", signal },
    options,
  );
};

export const getUsersGetUserByTelegramIdQueryKey = (telegramId: number) => {
  return [`/users/by-telegram-id/${telegramId}`] as const;
};

export const useUsersGetUserByTelegramIdQueryOptions = <
  TData = Awaited<ReturnType<typeof usersGetUserByTelegramId>>,
  TError = void | HTTPValidationError,
>(
  telegramId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usersGetUserByTelegramId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUsersGetUserByTelegramIdQueryKey(telegramId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof usersGetUserByTelegramId>>
  > = ({ signal }) =>
    usersGetUserByTelegramId(telegramId, requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetUserByTelegramId>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UsersGetUserByTelegramIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetUserByTelegramId>>
>;
export type UsersGetUserByTelegramIdQueryError = void | HTTPValidationError;

/**
 * @summary Get User By Telegram Id
 */
export const useUsersGetUserByTelegramId = <
  TData = Awaited<ReturnType<typeof usersGetUserByTelegramId>>,
  TError = void | HTTPValidationError,
>(
  telegramId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usersGetUserByTelegramId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useUsersGetUserByTelegramIdQueryOptions(
    telegramId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get user by id
 * @summary Get User By Id
 */
export const usersGetUserById = (
  userId: string,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<User>(
    { url: `/users/by-id/${userId}`, method: "GET", signal },
    options,
  );
};

export const getUsersGetUserByIdQueryKey = (userId: string) => {
  return [`/users/by-id/${userId}`] as const;
};

export const useUsersGetUserByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof usersGetUserById>>,
  TError = void | HTTPValidationError,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usersGetUserById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUsersGetUserByIdQueryKey(userId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof usersGetUserById>>
  > = ({ signal }) => usersGetUserById(userId, requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetUserById>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UsersGetUserByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetUserById>>
>;
export type UsersGetUserByIdQueryError = void | HTTPValidationError;

/**
 * @summary Get User By Id
 */
export const useUsersGetUserById = <
  TData = Awaited<ReturnType<typeof usersGetUserById>>,
  TError = void | HTTPValidationError,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usersGetUserById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useUsersGetUserByIdQueryOptions(userId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get user by email
 * @summary Get User By Innomail
 */
export const usersGetUserByInnomail = (
  email: string,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<User>(
    { url: `/users/by-innomail/${email}`, method: "GET", signal },
    options,
  );
};

export const getUsersGetUserByInnomailQueryKey = (email: string) => {
  return [`/users/by-innomail/${email}`] as const;
};

export const useUsersGetUserByInnomailQueryOptions = <
  TData = Awaited<ReturnType<typeof usersGetUserByInnomail>>,
  TError = void | HTTPValidationError,
>(
  email: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usersGetUserByInnomail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUsersGetUserByInnomailQueryKey(email);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof usersGetUserByInnomail>>
  > = ({ signal }) => usersGetUserByInnomail(email, requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetUserByInnomail>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UsersGetUserByInnomailQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetUserByInnomail>>
>;
export type UsersGetUserByInnomailQueryError = void | HTTPValidationError;

/**
 * @summary Get User By Innomail
 */
export const useUsersGetUserByInnomail = <
  TData = Awaited<ReturnType<typeof usersGetUserByInnomail>>,
  TError = void | HTTPValidationError,
>(
  email: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usersGetUserByInnomail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useUsersGetUserByInnomailQueryOptions(email, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get jwks for jwt
 * @summary Get Jwks
 */
export const tokensGetJwks = (
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<unknown>(
    { url: `/.well-known/jwks.json`, method: "GET", signal },
    options,
  );
};

export const getTokensGetJwksQueryKey = () => {
  return [`/.well-known/jwks.json`] as const;
};

export const useTokensGetJwksQueryOptions = <
  TData = Awaited<ReturnType<typeof tokensGetJwks>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof tokensGetJwks>>, TError, TData>
  >;
  request?: SecondParameter<typeof axiosQuery>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getTokensGetJwksQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof tokensGetJwks>>> = ({
    signal,
  }) => tokensGetJwks(requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof tokensGetJwks>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type TokensGetJwksQueryResult = NonNullable<
  Awaited<ReturnType<typeof tokensGetJwks>>
>;
export type TokensGetJwksQueryError = unknown;

/**
 * @summary Get Jwks
 */
export const useTokensGetJwks = <
  TData = Awaited<ReturnType<typeof tokensGetJwks>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof tokensGetJwks>>, TError, TData>
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useTokensGetJwksQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Generate access token for current user with user id in `uid` field
 * @summary Generate My Token
 */
export const tokensGenerateMyToken = (
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<TokenData>(
    { url: `/tokens/generate-my-token`, method: "GET", signal },
    options,
  );
};

export const getTokensGenerateMyTokenQueryKey = () => {
  return [`/tokens/generate-my-token`] as const;
};

export const useTokensGenerateMyTokenQueryOptions = <
  TData = Awaited<ReturnType<typeof tokensGenerateMyToken>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof tokensGenerateMyToken>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getTokensGenerateMyTokenQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof tokensGenerateMyToken>>
  > = ({ signal }) => tokensGenerateMyToken(requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof tokensGenerateMyToken>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type TokensGenerateMyTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof tokensGenerateMyToken>>
>;
export type TokensGenerateMyTokenQueryError = void;

/**
 * @summary Generate My Token
 */
export const useTokensGenerateMyToken = <
  TData = Awaited<ReturnType<typeof tokensGenerateMyToken>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof tokensGenerateMyToken>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useTokensGenerateMyTokenQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Generate access token with some sub in `sub` field
 * @summary Generate Token
 */
export const tokensGenerateToken = (
  params: TokensGenerateTokenParams,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<TokenData>(
    { url: `/tokens/generate-access-token`, method: "GET", params, signal },
    options,
  );
};

export const getTokensGenerateTokenQueryKey = (
  params: TokensGenerateTokenParams,
) => {
  return [
    `/tokens/generate-access-token`,
    ...(params ? [params] : []),
  ] as const;
};

export const useTokensGenerateTokenQueryOptions = <
  TData = Awaited<ReturnType<typeof tokensGenerateToken>>,
  TError = void | HTTPValidationError,
>(
  params: TokensGenerateTokenParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof tokensGenerateToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getTokensGenerateTokenQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof tokensGenerateToken>>
  > = ({ signal }) => tokensGenerateToken(params, requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof tokensGenerateToken>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type TokensGenerateTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof tokensGenerateToken>>
>;
export type TokensGenerateTokenQueryError = void | HTTPValidationError;

/**
 * @summary Generate Token
 */
export const useTokensGenerateToken = <
  TData = Awaited<ReturnType<typeof tokensGenerateToken>>,
  TError = void | HTTPValidationError,
>(
  params: TokensGenerateTokenParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof tokensGenerateToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useTokensGenerateTokenQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Generate access token for access users-related endpoints (/users/*).
 * @summary Generate Service Token
 */
export const tokensGenerateServiceToken = (
  params: TokensGenerateServiceTokenParams,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<TokenData>(
    { url: `/tokens/generate-service-token`, method: "GET", params, signal },
    options,
  );
};

export const getTokensGenerateServiceTokenQueryKey = (
  params: TokensGenerateServiceTokenParams,
) => {
  return [
    `/tokens/generate-service-token`,
    ...(params ? [params] : []),
  ] as const;
};

export const useTokensGenerateServiceTokenQueryOptions = <
  TData = Awaited<ReturnType<typeof tokensGenerateServiceToken>>,
  TError = void | HTTPValidationError,
>(
  params: TokensGenerateServiceTokenParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof tokensGenerateServiceToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getTokensGenerateServiceTokenQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof tokensGenerateServiceToken>>
  > = ({ signal }) =>
    tokensGenerateServiceToken(params, requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof tokensGenerateServiceToken>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type TokensGenerateServiceTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof tokensGenerateServiceToken>>
>;
export type TokensGenerateServiceTokenQueryError = void | HTTPValidationError;

/**
 * @summary Generate Service Token
 */
export const useTokensGenerateServiceToken = <
  TData = Awaited<ReturnType<typeof tokensGenerateServiceToken>>,
  TError = void | HTTPValidationError,
>(
  params: TokensGenerateServiceTokenParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof tokensGenerateServiceToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useTokensGenerateServiceTokenQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Generate access token for access https://sport.innopolis.university/api/swagger/
 * @summary Generate Sport Token
 */
export const tokensGenerateSportToken = (
  params?: TokensGenerateSportTokenParams,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<TokenData>(
    { url: `/tokens/generate-sport-token`, method: "GET", params, signal },
    options,
  );
};

export const getTokensGenerateSportTokenQueryKey = (
  params?: TokensGenerateSportTokenParams,
) => {
  return [`/tokens/generate-sport-token`, ...(params ? [params] : [])] as const;
};

export const useTokensGenerateSportTokenQueryOptions = <
  TData = Awaited<ReturnType<typeof tokensGenerateSportToken>>,
  TError = void | HTTPValidationError,
>(
  params?: TokensGenerateSportTokenParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof tokensGenerateSportToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getTokensGenerateSportTokenQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof tokensGenerateSportToken>>
  > = ({ signal }) => tokensGenerateSportToken(params, requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof tokensGenerateSportToken>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type TokensGenerateSportTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof tokensGenerateSportToken>>
>;
export type TokensGenerateSportTokenQueryError = void | HTTPValidationError;

/**
 * @summary Generate Sport Token
 */
export const useTokensGenerateSportToken = <
  TData = Awaited<ReturnType<typeof tokensGenerateSportToken>>,
  TError = void | HTTPValidationError,
>(
  params?: TokensGenerateSportTokenParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof tokensGenerateSportToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useTokensGenerateSportTokenQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Logout
 */
export const logout = (
  params: LogoutParams,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<unknown>(
    { url: `/logout`, method: "GET", params, signal },
    options,
  );
};

export const getLogoutQueryKey = (params: LogoutParams) => {
  return [`/logout`, ...(params ? [params] : [])] as const;
};

export const useLogoutQueryOptions = <
  TData = Awaited<ReturnType<typeof logout>>,
  TError = void | HTTPValidationError,
>(
  params: LogoutParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogoutQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logout>>> = ({
    signal,
  }) => logout(params, requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof logout>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type LogoutQueryResult = NonNullable<Awaited<ReturnType<typeof logout>>>;
export type LogoutQueryError = void | HTTPValidationError;

/**
 * @summary Logout
 */
export const useLogout = <
  TData = Awaited<ReturnType<typeof logout>>,
  TError = void | HTTPValidationError,
>(
  params: LogoutParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useLogoutQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};
