/**
 * Generated by orval v6.29.1 üç∫
 * Do not edit manually.
 * InNoHassle-Search
 * 
### About this project

 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";
import { axiosQuery } from "./axios";
import { queryOptionsMutator } from "./query";
export type MoodleGetMoodleFiles200Item = { [key: string]: any };

export type MoodlePreviewMoodleParams = {
  course_id: number;
  module_id: number;
  filename: string;
};

export type SearchAddUserFeedbackFeedback =
  (typeof SearchAddUserFeedbackFeedback)[keyof typeof SearchAddUserFeedbackFeedback];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SearchAddUserFeedbackFeedback = {
  like: "like",
  dislike: "dislike",
} as const;

export type SearchAddUserFeedbackParams = {
  response_index: number;
  feedback: SearchAddUserFeedbackFeedback;
};

export type SearchSearchByQueryParams = {
  query: string;
  limit?: number;
  use_ai?: boolean;
};

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type TelegramSourceType =
  (typeof TelegramSourceType)[keyof typeof TelegramSourceType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TelegramSourceType = {
  telegram: "telegram",
} as const;

export interface TelegramSource {
  /** Breadcrumbs to the resource. */
  breadcrumbs: string[];
  /** Title of the chat, channel, group */
  chat_title: string;
  /** Username of the chat, channel, group */
  chat_username: string;
  /** Display name of the resource. */
  display_name: string;
  /** Link to the message */
  link: string;
  /** Message ID in the chat */
  message_id: number;
  type: TelegramSourceType;
}

export type SearchTaskStatus =
  (typeof SearchTaskStatus)[keyof typeof SearchTaskStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SearchTaskStatus = {
  pending: "pending",
  completed: "completed",
  failed: "failed",
} as const;

export interface SearchTask {
  query: string;
  status: SearchTaskStatus;
  task_id: string;
}

export type SearchResultStatus =
  (typeof SearchResultStatus)[keyof typeof SearchResultStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SearchResultStatus = {
  completed: "completed",
  failed: "failed",
} as const;

export interface SearchResult {
  result?: MoodleFileResult[];
  status: SearchResultStatus;
  task_id: string;
}

/**
 * Assigned search query index
 */
export type SearchResponsesSearchQueryId = string | null;

export interface SearchResponses {
  /** Responses to the search query. */
  responses: SearchResponse[];
  /** Assigned search query index */
  search_query_id: SearchResponsesSearchQueryId;
  /** Text that was searched for. */
  searched_for: string;
}

/**
 * Relevant source for the search.
 */
export type SearchResponseSource =
  | MoodleFileSource
  | MoodleUrlSource
  | MoodleUnknownSource
  | TelegramSource;

/**
 * Score of the search response. Multiple scores if was an aggregation of multiple chunks. Optional.
 */
export type SearchResponseScore = number | number[] | null;

export interface SearchResponse {
  /** Score of the search response. Multiple scores if was an aggregation of multiple chunks. Optional. */
  score: SearchResponseScore;
  /** Relevant source for the search. */
  source: SearchResponseSource;
}

export interface PdfLocation {
  /** Page index in the PDF file. Starts from 1. */
  page_index: number;
}

export type MoodleUrlSourceType =
  (typeof MoodleUrlSourceType)[keyof typeof MoodleUrlSourceType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MoodleUrlSourceType = {
  "moodle-url": "moodle-url",
} as const;

export interface MoodleUrlSource {
  /** Breadcrumbs to the resource. */
  breadcrumbs: string[];
  /** Display name of the resource. */
  display_name: string;
  /** Anchor URL to the resource on Moodle. */
  link: string;
  type: MoodleUrlSourceType;
  /** URL of the resource */
  url: string;
}

export type MoodleUnknownSourceType =
  (typeof MoodleUnknownSourceType)[keyof typeof MoodleUnknownSourceType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MoodleUnknownSourceType = {
  "moodle-unknown": "moodle-unknown",
} as const;

export interface MoodleUnknownSource {
  /** Breadcrumbs to the resource. */
  breadcrumbs: string[];
  /** Display name of the resource. */
  display_name: string;
  /** Anchor URL to the resource on Moodle. */
  link: string;
  type: MoodleUnknownSourceType;
}

export type MoodleFileSourceType =
  (typeof MoodleFileSourceType)[keyof typeof MoodleFileSourceType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MoodleFileSourceType = {
  "moodle-file": "moodle-file",
} as const;

/**
 * URL to get the preview of the resource.
 */
export type MoodleFileSourceResourcePreviewUrl = string | null;

/**
 * URL to download the resource.
 */
export type MoodleFileSourceResourceDownloadUrl = string | null;

export type MoodleFileSourcePreviewLocation = PdfLocation | null;

export interface MoodleFileSource {
  /** Breadcrumbs to the resource. */
  breadcrumbs: string[];
  /** Display name of the resource. */
  display_name: string;
  /** Anchor URL to the resource on Moodle. */
  link: string;
  preview_location: MoodleFileSourcePreviewLocation;
  /** URL to download the resource. */
  resource_download_url: MoodleFileSourceResourceDownloadUrl;
  /** URL to get the preview of the resource. */
  resource_preview_url: MoodleFileSourceResourcePreviewUrl;
  type: MoodleFileSourceType;
}

export type MoodleFileResultScore = number[] | number | null;

export interface MoodleFileResult {
  course_id: number;
  filename: string;
  module_id: number;
  score?: MoodleFileResultScore;
}

export interface MoodleCourse {
  course_id: number;
  coursecategory: string;
  enddate: number;
  fullname: string;
  /** MongoDB document ObjectID */
  id: string;
  startdate: number;
}

export type MoodleContentSchemaOutputTimemodified = number | null;

export type MoodleContentSchemaOutputTimecreated = number | null;

export interface MoodleContentSchemaOutput {
  filename: string;
  timecreated: MoodleContentSchemaOutputTimecreated;
  timemodified: MoodleContentSchemaOutputTimemodified;
  type: string;
  uploaded: boolean;
}

export interface MoodleEntry {
  contents: MoodleContentSchemaOutput[];
  course_fullname: string;
  course_id: number;
  /** MongoDB document ObjectID */
  id: string;
  module_id: number;
  module_modname: string;
  module_name: string;
  section_id: number;
  section_summary: string;
}

export type MoodleContentSchemaInputTimemodified = number | null;

export type MoodleContentSchemaInputTimecreated = number | null;

export interface MoodleContentSchemaInput {
  filename: string;
  timecreated?: MoodleContentSchemaInputTimecreated;
  timemodified?: MoodleContentSchemaInputTimemodified;
  type: string;
  uploaded?: boolean;
}

export type MessageSchemaText = string | null;

export type MessageSchemaCaption = string | null;

export interface MessageSchema {
  caption: MessageSchemaCaption;
  chat: Chat;
  date: string;
  id: number;
  sender_chat: Chat;
  text: MessageSchemaText;
}

export interface InModule {
  contents?: MoodleContentSchemaInput[];
  id: number;
  modname: string;
  name: string;
}

export interface InSection {
  id: number;
  modules: InModule[];
  summary: string;
}

export interface InSections {
  course_fullname: string;
  course_id: number;
  sections: InSection[];
}

export interface InCourse {
  coursecategory: string;
  enddate: number;
  fullname: string;
  id: number;
  startdate: number;
}

export interface InCourses {
  courses: InCourse[];
}

export interface InContents {
  contents: MoodleContentSchemaInput[];
  course_id: number;
  module_id: number;
}

export interface InContent {
  content: MoodleContentSchemaInput;
  course_id: number;
  module_id: number;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export interface FlattenInContentsWithPresignedUrl {
  content: MoodleContentSchemaOutput;
  course_id: number;
  module_id: number;
  presigned_url: string;
}

export interface Detail {
  detail: string;
}

export type DBMessageSchemaText = string | null;

export type DBMessageSchemaCaption = string | null;

export interface DBMessageSchema {
  caption: DBMessageSchemaCaption;
  chat_id: number;
  chat_title: string;
  chat_username: string;
  date: string;
  link: string;
  message_id: number;
  text: DBMessageSchemaText;
}

export interface Chat {
  id: number;
  title: string;
  type: string;
  username: string;
}

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];

/**
 * @summary Search By Query
 */
export const searchSearchByQuery = (
  params: SearchSearchByQueryParams,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<SearchResponses>(
    { url: `/search/search`, method: "GET", params, signal },
    options,
  );
};

export const getSearchSearchByQueryQueryKey = (
  params: SearchSearchByQueryParams,
) => {
  return [`/search/search`, ...(params ? [params] : [])] as const;
};

export const useSearchSearchByQueryQueryOptions = <
  TData = Awaited<ReturnType<typeof searchSearchByQuery>>,
  TError = void | HTTPValidationError,
>(
  params: SearchSearchByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchSearchByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSearchSearchByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof searchSearchByQuery>>
  > = ({ signal }) => searchSearchByQuery(params, requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof searchSearchByQuery>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SearchSearchByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchSearchByQuery>>
>;
export type SearchSearchByQueryQueryError = void | HTTPValidationError;

/**
 * @summary Search By Query
 */
export const useSearchSearchByQuery = <
  TData = Awaited<ReturnType<typeof searchSearchByQuery>>,
  TError = void | HTTPValidationError,
>(
  params: SearchSearchByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchSearchByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useSearchSearchByQueryQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Add User Feedback
 */
export const searchAddUserFeedback = (
  searchQueryId: string,
  params: SearchAddUserFeedbackParams,
  options?: SecondParameter<typeof axiosQuery>,
) => {
  return axiosQuery<unknown>(
    { url: `/search/search/${searchQueryId}/feedback`, method: "POST", params },
    options,
  );
};

export const getSearchAddUserFeedbackMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof searchAddUserFeedback>>,
    TError,
    { searchQueryId: string; params: SearchAddUserFeedbackParams },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof searchAddUserFeedback>>,
  TError,
  { searchQueryId: string; params: SearchAddUserFeedbackParams },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof searchAddUserFeedback>>,
    { searchQueryId: string; params: SearchAddUserFeedbackParams }
  > = (props) => {
    const { searchQueryId, params } = props ?? {};

    return searchAddUserFeedback(searchQueryId, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SearchAddUserFeedbackMutationResult = NonNullable<
  Awaited<ReturnType<typeof searchAddUserFeedback>>
>;

export type SearchAddUserFeedbackMutationError = HTTPValidationError;

/**
 * @summary Add User Feedback
 */
export const useSearchAddUserFeedback = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof searchAddUserFeedback>>,
    TError,
    { searchQueryId: string; params: SearchAddUserFeedbackParams },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationResult<
  Awaited<ReturnType<typeof searchAddUserFeedback>>,
  TError,
  { searchQueryId: string; params: SearchAddUserFeedbackParams },
  TContext
> => {
  const mutationOptions = getSearchAddUserFeedbackMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Determining whether to save the message or overwrite it
 * @summary Save Or Update Message
 */
export const telegramSaveOrUpdateMessage = (
  messageSchema: MessageSchema,
  options?: SecondParameter<typeof axiosQuery>,
) => {
  return axiosQuery<DBMessageSchema>(
    {
      url: `/telegram/messages`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: messageSchema,
    },
    options,
  );
};

export const getTelegramSaveOrUpdateMessageMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof telegramSaveOrUpdateMessage>>,
    TError,
    { data: MessageSchema },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof telegramSaveOrUpdateMessage>>,
  TError,
  { data: MessageSchema },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof telegramSaveOrUpdateMessage>>,
    { data: MessageSchema }
  > = (props) => {
    const { data } = props ?? {};

    return telegramSaveOrUpdateMessage(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TelegramSaveOrUpdateMessageMutationResult = NonNullable<
  Awaited<ReturnType<typeof telegramSaveOrUpdateMessage>>
>;
export type TelegramSaveOrUpdateMessageMutationBody = MessageSchema;
export type TelegramSaveOrUpdateMessageMutationError = HTTPValidationError;

/**
 * @summary Save Or Update Message
 */
export const useTelegramSaveOrUpdateMessage = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof telegramSaveOrUpdateMessage>>,
    TError,
    { data: MessageSchema },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationResult<
  Awaited<ReturnType<typeof telegramSaveOrUpdateMessage>>,
  TError,
  { data: MessageSchema },
  TContext
> => {
  const mutationOptions =
    getTelegramSaveOrUpdateMessageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Preview Moodle
 */
export const moodlePreviewMoodle = (
  params: MoodlePreviewMoodleParams,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<unknown>(
    { url: `/moodle/preview`, method: "GET", params, signal },
    options,
  );
};

export const getMoodlePreviewMoodleQueryKey = (
  params: MoodlePreviewMoodleParams,
) => {
  return [`/moodle/preview`, ...(params ? [params] : [])] as const;
};

export const useMoodlePreviewMoodleQueryOptions = <
  TData = Awaited<ReturnType<typeof moodlePreviewMoodle>>,
  TError = void | HTTPValidationError,
>(
  params: MoodlePreviewMoodleParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moodlePreviewMoodle>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMoodlePreviewMoodleQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moodlePreviewMoodle>>
  > = ({ signal }) => moodlePreviewMoodle(params, requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof moodlePreviewMoodle>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type MoodlePreviewMoodleQueryResult = NonNullable<
  Awaited<ReturnType<typeof moodlePreviewMoodle>>
>;
export type MoodlePreviewMoodleQueryError = void | HTTPValidationError;

/**
 * @summary Preview Moodle
 */
export const useMoodlePreviewMoodle = <
  TData = Awaited<ReturnType<typeof moodlePreviewMoodle>>,
  TError = void | HTTPValidationError,
>(
  params: MoodlePreviewMoodleParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moodlePreviewMoodle>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useMoodlePreviewMoodleQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Get Moodle Files
 */
export const moodleGetMoodleFiles = (
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<MoodleGetMoodleFiles200Item[]>(
    { url: `/moodle/files`, method: "GET", signal },
    options,
  );
};

export const getMoodleGetMoodleFilesQueryKey = () => {
  return [`/moodle/files`] as const;
};

export const useMoodleGetMoodleFilesQueryOptions = <
  TData = Awaited<ReturnType<typeof moodleGetMoodleFiles>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof moodleGetMoodleFiles>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMoodleGetMoodleFilesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moodleGetMoodleFiles>>
  > = ({ signal }) => moodleGetMoodleFiles(requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof moodleGetMoodleFiles>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type MoodleGetMoodleFilesQueryResult = NonNullable<
  Awaited<ReturnType<typeof moodleGetMoodleFiles>>
>;
export type MoodleGetMoodleFilesQueryError = unknown;

/**
 * @summary Get Moodle Files
 */
export const useMoodleGetMoodleFiles = <
  TData = Awaited<ReturnType<typeof moodleGetMoodleFiles>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof moodleGetMoodleFiles>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useMoodleGetMoodleFilesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Courses
 */
export const moodleCourses = (
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<MoodleCourse[]>(
    { url: `/moodle/courses`, method: "GET", signal },
    options,
  );
};

export const getMoodleCoursesQueryKey = () => {
  return [`/moodle/courses`] as const;
};

export const useMoodleCoursesQueryOptions = <
  TData = Awaited<ReturnType<typeof moodleCourses>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof moodleCourses>>, TError, TData>
  >;
  request?: SecondParameter<typeof axiosQuery>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMoodleCoursesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof moodleCourses>>> = ({
    signal,
  }) => moodleCourses(requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof moodleCourses>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type MoodleCoursesQueryResult = NonNullable<
  Awaited<ReturnType<typeof moodleCourses>>
>;
export type MoodleCoursesQueryError = unknown;

/**
 * @summary Courses
 */
export const useMoodleCourses = <
  TData = Awaited<ReturnType<typeof moodleCourses>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof moodleCourses>>, TError, TData>
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useMoodleCoursesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Batch Upsert Courses
 */
export const moodleBatchUpsertCourses = (
  inCourses: InCourses,
  options?: SecondParameter<typeof axiosQuery>,
) => {
  return axiosQuery<unknown>(
    {
      url: `/moodle/batch-courses`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: inCourses,
    },
    options,
  );
};

export const getMoodleBatchUpsertCoursesMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleBatchUpsertCourses>>,
    TError,
    { data: InCourses },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof moodleBatchUpsertCourses>>,
  TError,
  { data: InCourses },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof moodleBatchUpsertCourses>>,
    { data: InCourses }
  > = (props) => {
    const { data } = props ?? {};

    return moodleBatchUpsertCourses(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MoodleBatchUpsertCoursesMutationResult = NonNullable<
  Awaited<ReturnType<typeof moodleBatchUpsertCourses>>
>;
export type MoodleBatchUpsertCoursesMutationBody = InCourses;
export type MoodleBatchUpsertCoursesMutationError = HTTPValidationError;

/**
 * @summary Batch Upsert Courses
 */
export const useMoodleBatchUpsertCourses = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleBatchUpsertCourses>>,
    TError,
    { data: InCourses },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationResult<
  Awaited<ReturnType<typeof moodleBatchUpsertCourses>>,
  TError,
  { data: InCourses },
  TContext
> => {
  const mutationOptions = getMoodleBatchUpsertCoursesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Courses Content
 */
export const moodleCoursesContent = (
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<MoodleEntry[]>(
    { url: `/moodle/courses-content`, method: "GET", signal },
    options,
  );
};

export const getMoodleCoursesContentQueryKey = () => {
  return [`/moodle/courses-content`] as const;
};

export const useMoodleCoursesContentQueryOptions = <
  TData = Awaited<ReturnType<typeof moodleCoursesContent>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof moodleCoursesContent>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMoodleCoursesContentQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moodleCoursesContent>>
  > = ({ signal }) => moodleCoursesContent(requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof moodleCoursesContent>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type MoodleCoursesContentQueryResult = NonNullable<
  Awaited<ReturnType<typeof moodleCoursesContent>>
>;
export type MoodleCoursesContentQueryError = unknown;

/**
 * @summary Courses Content
 */
export const useMoodleCoursesContent = <
  TData = Awaited<ReturnType<typeof moodleCoursesContent>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof moodleCoursesContent>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useMoodleCoursesContentQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Course Content
 */
export const moodleCourseContent = (
  inSections: InSections[],
  options?: SecondParameter<typeof axiosQuery>,
) => {
  return axiosQuery<unknown>(
    {
      url: `/moodle/set-course-content`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: inSections,
    },
    options,
  );
};

export const getMoodleCourseContentMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleCourseContent>>,
    TError,
    { data: InSections[] },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof moodleCourseContent>>,
  TError,
  { data: InSections[] },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof moodleCourseContent>>,
    { data: InSections[] }
  > = (props) => {
    const { data } = props ?? {};

    return moodleCourseContent(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MoodleCourseContentMutationResult = NonNullable<
  Awaited<ReturnType<typeof moodleCourseContent>>
>;
export type MoodleCourseContentMutationBody = InSections[];
export type MoodleCourseContentMutationError = HTTPValidationError;

/**
 * @summary Course Content
 */
export const useMoodleCourseContent = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleCourseContent>>,
    TError,
    { data: InSections[] },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationResult<
  Awaited<ReturnType<typeof moodleCourseContent>>,
  TError,
  { data: InSections[] },
  TContext
> => {
  const mutationOptions = getMoodleCourseContentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Need To Upload Contents
 */
export const moodleNeedToUploadContents = (
  inContents: InContents[],
  options?: SecondParameter<typeof axiosQuery>,
) => {
  return axiosQuery<FlattenInContentsWithPresignedUrl[]>(
    {
      url: `/moodle/need-to-upload-contents`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: inContents,
    },
    options,
  );
};

export const getMoodleNeedToUploadContentsMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleNeedToUploadContents>>,
    TError,
    { data: InContents[] },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof moodleNeedToUploadContents>>,
  TError,
  { data: InContents[] },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof moodleNeedToUploadContents>>,
    { data: InContents[] }
  > = (props) => {
    const { data } = props ?? {};

    return moodleNeedToUploadContents(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MoodleNeedToUploadContentsMutationResult = NonNullable<
  Awaited<ReturnType<typeof moodleNeedToUploadContents>>
>;
export type MoodleNeedToUploadContentsMutationBody = InContents[];
export type MoodleNeedToUploadContentsMutationError = HTTPValidationError;

/**
 * @summary Need To Upload Contents
 */
export const useMoodleNeedToUploadContents = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleNeedToUploadContents>>,
    TError,
    { data: InContents[] },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationResult<
  Awaited<ReturnType<typeof moodleNeedToUploadContents>>,
  TError,
  { data: InContents[] },
  TContext
> => {
  const mutationOptions = getMoodleNeedToUploadContentsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Content Uploaded
 */
export const moodleContentUploaded = (
  inContent: InContent,
  options?: SecondParameter<typeof axiosQuery>,
) => {
  return axiosQuery<unknown>(
    {
      url: `/moodle/content-uploaded`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: inContent,
    },
    options,
  );
};

export const getMoodleContentUploadedMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleContentUploaded>>,
    TError,
    { data: InContent },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof moodleContentUploaded>>,
  TError,
  { data: InContent },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof moodleContentUploaded>>,
    { data: InContent }
  > = (props) => {
    const { data } = props ?? {};

    return moodleContentUploaded(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MoodleContentUploadedMutationResult = NonNullable<
  Awaited<ReturnType<typeof moodleContentUploaded>>
>;
export type MoodleContentUploadedMutationBody = InContent;
export type MoodleContentUploadedMutationError = HTTPValidationError;

/**
 * @summary Content Uploaded
 */
export const useMoodleContentUploaded = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleContentUploaded>>,
    TError,
    { data: InContent },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationResult<
  Awaited<ReturnType<typeof moodleContentUploaded>>,
  TError,
  { data: InContent },
  TContext
> => {
  const mutationOptions = getMoodleContentUploadedMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get Corpora
 */
export const computeGetCorpora = (
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<unknown>(
    { url: `/compute/corpora`, method: "GET", signal },
    options,
  );
};

export const getComputeGetCorporaQueryKey = () => {
  return [`/compute/corpora`] as const;
};

export const useComputeGetCorporaQueryOptions = <
  TData = Awaited<ReturnType<typeof computeGetCorpora>>,
  TError = Detail,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof computeGetCorpora>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getComputeGetCorporaQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof computeGetCorpora>>
  > = ({ signal }) => computeGetCorpora(requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof computeGetCorpora>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ComputeGetCorporaQueryResult = NonNullable<
  Awaited<ReturnType<typeof computeGetCorpora>>
>;
export type ComputeGetCorporaQueryError = Detail;

/**
 * @summary Get Corpora
 */
export const useComputeGetCorpora = <
  TData = Awaited<ReturnType<typeof computeGetCorpora>>,
  TError = Detail,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof computeGetCorpora>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useComputeGetCorporaQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Get Pending Search Queries
 */
export const computeGetPendingSearchQueries = (
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<SearchTask[]>(
    { url: `/compute/pending-searchs`, method: "GET", signal },
    options,
  );
};

export const getComputeGetPendingSearchQueriesQueryKey = () => {
  return [`/compute/pending-searchs`] as const;
};

export const useComputeGetPendingSearchQueriesQueryOptions = <
  TData = Awaited<ReturnType<typeof computeGetPendingSearchQueries>>,
  TError = Detail,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof computeGetPendingSearchQueries>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getComputeGetPendingSearchQueriesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof computeGetPendingSearchQueries>>
  > = ({ signal }) => computeGetPendingSearchQueries(requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof computeGetPendingSearchQueries>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ComputeGetPendingSearchQueriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof computeGetPendingSearchQueries>>
>;
export type ComputeGetPendingSearchQueriesQueryError = Detail;

/**
 * @summary Get Pending Search Queries
 */
export const useComputeGetPendingSearchQueries = <
  TData = Awaited<ReturnType<typeof computeGetPendingSearchQueries>>,
  TError = Detail,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof computeGetPendingSearchQueries>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useComputeGetPendingSearchQueriesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Post Completed Search Queries
 */
export const computePostCompletedSearchQueries = (
  searchResult: SearchResult[],
  options?: SecondParameter<typeof axiosQuery>,
) => {
  return axiosQuery<unknown>(
    {
      url: `/compute/completed-searchs`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: searchResult,
    },
    options,
  );
};

export const getComputePostCompletedSearchQueriesMutationOptions = <
  TError = Detail | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof computePostCompletedSearchQueries>>,
    TError,
    { data: SearchResult[] },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof computePostCompletedSearchQueries>>,
  TError,
  { data: SearchResult[] },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof computePostCompletedSearchQueries>>,
    { data: SearchResult[] }
  > = (props) => {
    const { data } = props ?? {};

    return computePostCompletedSearchQueries(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ComputePostCompletedSearchQueriesMutationResult = NonNullable<
  Awaited<ReturnType<typeof computePostCompletedSearchQueries>>
>;
export type ComputePostCompletedSearchQueriesMutationBody = SearchResult[];
export type ComputePostCompletedSearchQueriesMutationError =
  | Detail
  | HTTPValidationError;

/**
 * @summary Post Completed Search Queries
 */
export const useComputePostCompletedSearchQueries = <
  TError = Detail | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof computePostCompletedSearchQueries>>,
    TError,
    { data: SearchResult[] },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationResult<
  Awaited<ReturnType<typeof computePostCompletedSearchQueries>>,
  TError,
  { data: SearchResult[] },
  TContext
> => {
  const mutationOptions =
    getComputePostCompletedSearchQueriesMutationOptions(options);

  return useMutation(mutationOptions);
};
